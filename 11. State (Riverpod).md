# Wide State Management

Untuk mengelola state yang lebih dalam kita dapat melakukan dengan beberapa cara.

## Package Pihak Petiga

`Riverpod` versi modern dari `Provider` dengan penulis yang sama. Ada 2 konsep utama dalam penggunaan `wide-state-management` ini.

```bash
flutter pub add flutter_riverpod
flutter pub add riverpod_annotation
flutter pub add riverpod_generator
flutter pub add build_runner
```

Disini akan dibahas secara spesifik wide state management menggunakan riverpod.

### 1. Wrap Komponen

Wrap kompnonen dengan `ProviderScope`

```dart
void main(){
    runApp(const ProviderScope(child: App()))
}
```

### 2. Provider

Terdapat beberapa jenis provider yang bisa digunakan:

- Provider → Read-only values
- StateProvider → Simple state management
- FutureProvider → Async data (e.g., API calls)
- StreamProvider → Real-time updates (e.g., Firebase)
- StateNotifierProvider → Advanced state management

```dart
// read-only
final mealsProvider = Provider((ref){
    return dummyMeals
})

// read and write
final counterProvider = StateProvider<int>((ref) => 0);
final count = ref.watch(counterProvider); // read in component
onPressed: () => ref.read(counterProvider.notifier).state++,  // write in component
```

### StateProvider VS StateNotifier

Kita ambil kasus **Todo App** (sederhana tapi cukup kompleks untuk membedakan).

#### StateProvider

Kalau pakai `StateProvider`, kita langsung simpan list todo di dalamnya.

Semua logika (nambah, hapus, toggle) dilakukan di luar.

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Model sederhana
class Todo {
  final String id;
  final String title;
  final bool completed;

  Todo({
    required this.id,
    required this.title,
    this.completed = false,
  });

  Todo copyWith({String? title, bool? completed}) {
    return Todo(
      id: id,
      title: title ?? this.title,
      completed: completed ?? this.completed,
    );
  }
}

// StateProvider: langsung simpan list Todo
final todosProvider = StateProvider<List<Todo>>((ref) => []);

// Contoh penggunaan di widget
// Tambah todo
void addTodo(WidgetRef ref, String title) {
  final todos = ref.read(todosProvider.notifier);
  todos.state = [
    ...todos.state,
    Todo(id: DateTime.now().toString(), title: title),
  ];
}

// Toggle
void toggleTodo(WidgetRef ref, String id) {
  final todos = ref.read(todosProvider.notifier);
  todos.state = todos.state.map((todo) {
    if (todo.id == id) {
      return todo.copyWith(completed: !todo.completed);
    }
    return todo;
  }).toList();
}
```

👉 Kekurangan: logika bercampur di luar provider, kode bisa cepat berantakan kalau fitur makin banyak.

#### StateNotifier

Di sini kita bikin class khusus (`TodoNotifier`) untuk mengelola semua logika.
State lebih terorganisir, gampang dikembangkan.

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Model sama dengan sebelumnya
class Todo {
  final String id;
  final String title;
  final bool completed;

  Todo({
    required this.id,
    required this.title,
    this.completed = false,
  });

  Todo copyWith({String? title, bool? completed}) {
    return Todo(
      id: id,
      title: title ?? this.title,
      completed: completed ?? this.completed,
    );
  }
}

// StateNotifier untuk mengelola list Todo
class TodoNotifier extends StateNotifier<List<Todo>> {
  TodoNotifier() : super([]);

  void add(String title) {
    state = [
      ...state,
      Todo(id: DateTime.now().toString(), title: title),
    ];
  }

  void toggle(String id) {
    state = state.map((todo) {
      if (todo.id == id) {
        return todo.copyWith(completed: !todo.completed);
      }
      return todo;
    }).toList();
  }

  void remove(String id) {
    state = state.where((todo) => todo.id != id).toList();
  }
}

// Provider
final todosProvider =
    StateNotifierProvider<TodoNotifier, List<Todo>>((ref) => TodoNotifier());
```

👉 Keuntungan: semua logika terkapsulasi di dalam `TodoNotifier`, gampang dipakai di UI:

```dart
ref.read(todosProvider.notifier).add("Belajar Riverpod"); // Tambah
ref.read(todosProvider.notifier).toggle(todoId); // Toggle
ref.read(todosProvider.notifier).remove(todoId); // Remove
```

### Consumer

Ganti class widget untuk extend dari `ConsumerWidget` jika stateless dan `ConsumerStatefulWidget` jika statefull.

Ganti class state untuk extend dari `ConsumerState` jika statefull.

Didalamnya kita bisa maengakses variabel `ref.watch(stateName)` di `build` agar dire-render ketika perubahan terjadi.

## 🔑 Inti Perbedaan di Contoh Ini

- **`StateProvider`** → data + logika bercampur di widget atau helper function.
- **`StateNotifier`** → logika dikelompokkan di satu tempat (class), lebih mudah dipelihara & scalable.

Keren 👍 — berikut penjelasan **visual + konsep alur kerja Riverpod** dalam bentuk diagram dan narasi supaya kamu paham **kenapa nggak perlu wrapping provider di parent widget** seperti di React atau `provider` Flutter lama.

---

## 🧭 **Konsep Umum: “Global Provider Container”**

```yml
        ┌────────────────────────────┐
        │        ProviderScope       │   ← satu kali di root app
        │ (menyediakan container)    │
        └─────────────┬──────────────┘
                      │
                      ▼
        ┌────────────────────────────┐
        │     ProviderContainer      │
        │ (tempat semua provider     │
        │  didaftarkan & di-manage)  │
        └─────────────┬──────────────┘
                      │
     ┌────────────────┴────────────────┐
     │                                 │
     ▼                                 ▼
┌──────────────┐               ┌──────────────┐
│ counterProvider │            │ authProvider │
│ (StateProvider) │            │ (FutureProv.)│
└──────────────┘               └──────────────┘
     │                                 │
     ▼                                 ▼
┌──────────────┐               ┌──────────────┐
│ Widget A     │               │ Widget B     │
│ ref.watch(...)│              │ ref.read(...)│
└──────────────┘               └──────────────┘
```

---

## 🧩 **Alur Kerja**

1. **`ProviderScope`** di `main.dart` hanya **sekali**:

   ```dart
   void main() {
     runApp(ProviderScope(child: MyApp()));
   }
   ```

   Ini membuat sebuah **`ProviderContainer`**, yaitu tempat semua provider hidup.

2. Kamu mendefinisikan provider di mana pun:

   ```dart
   final counterProvider = StateProvider<int>((ref) => 0);
   ```

3. Saat kamu panggil di widget:

   ```dart
   final count = ref.watch(counterProvider);
   ```

   Maka `ref` akan:

   - Minta nilai ke `ProviderContainer`
   - Kalau belum ada instance → dibuat otomatis
   - Kalau sudah ada → ambil state terkini

4. Semua dependensi antar-provider dikelola otomatis oleh container (termasuk disposal dan reactivity).

---

## 🧠 **Analogi Singkat**

Bayangkan `ProviderScope` itu seperti **power station** ⚡
Semua `provider` kamu (counter, auth, theme, dsb) seperti **jalur listrik**.

Setiap widget yang butuh state cukup **colok ke stop kontak** (`ref.watch(provider)`) tanpa perlu bikin power station sendiri.

---

## 🧱 **Bonus: Gimana Kalau Butuh Scope Khusus**

Kamu **bisa** punya scope provider lokal (misal di halaman tertentu):

```dart
ProviderScope(
  overrides: [
    counterProvider.overrideWith((ref) => StateController(100)),
  ],
  child: CounterPage(),
);
```

➡️ Ini membuat container baru hanya untuk `CounterPage`, tapi tetap tidak perlu “membungkus provider” satu per satu.

---

## ✅ **Kesimpulan**

| Konsep                   | Provider (lama) | Riverpod          |
| ------------------------ | --------------- | ----------------- |
| Harus wrap tiap provider | ✅ Ya            | ❌ Tidak           |
| Context-bound            | ✅ Ya            | ❌ Tidak           |
| Global management        | ⚙️ Terbatas     | ✅ `ProviderScope` |
| Multi-scope support      | ❌ Rumit         | ✅ Built-in        |
| Dependency injection     | ⚙️ Manual       | ✅ Otomatis        |

---

Kalau kamu mau, saya bisa bantu lanjut bikin **diagram versi visual (gambar)** dari arsitektur ini — mirip mindmap atau flowchart gaya profesional.
Apakah kamu mau saya buatkan diagram visualnya?

✅ Tepat sekali!
Ini salah satu **perbedaan utama** dan **kekuatan Riverpod** dibandingkan state management lain seperti **Provider** di Flutter atau **Context API** di React.

Mari saya jelaskan dengan detail biar kamu benar-benar paham konsepnya 👇

---

## 🧩 1. Perbedaan Filosofi Dasar

### 🧠 Di React (atau Flutter Provider)

Kamu **harus membungkus** komponen/Widget parent dengan provider agar context bisa di-*consume* di bawahnya.

Contoh React (atau Flutter Provider):

```dart
// Provider (lama)
return ChangeNotifierProvider(
  create: (_) => CounterNotifier(),
  child: MyApp(),
);
```

➡️ Artinya, setiap widget yang butuh state harus *dalam tree* provider itu.

Kalau salah scope (misal provider tidak di atas widget yang butuh), akan muncul error seperti:

> “Provider not found for context”

---

### ⚙️ Di Riverpod

Kamu **tidak perlu membungkus** widget dengan provider manual.

Cukup **daftarkan provider-nya di mana saja** (biasanya di file `.dart` terpisah), lalu **gunakan langsung dengan import dan `ref.watch()`**.

Satu-satunya hal yang perlu kamu lakukan di level global hanya:

```dart
runApp(ProviderScope(child: MyApp()));
```

Itu *sekali saja di root app* — Riverpod yang akan mengurus semua provider di dalamnya.

---

## 📦 2. Contoh Perbandingan

### Tanpa Riverpod (Provider)

```dart
ChangeNotifierProvider(
  create: (_) => CounterNotifier(),
  child: MyApp(),
);
```

### Dengan Riverpod

```dart
void main() {
  runApp(const ProviderScope(child: MyApp())); // hanya ini
}
```

Kemudian di file manapun:

```dart
final counterProvider = StateProvider<int>((ref) => 0);
```

Lalu di widget:

```dart
class CounterPage extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final count = ref.watch(counterProvider);
    return Text('$count');
  }
}
```

➡️ Kamu hanya perlu **import file provider-nya**, tidak perlu bungkus widget dengan provider lagi.

---

## ⚡ 3. Kenapa Bisa Begitu?

Karena Riverpod menggunakan **container global (ProviderContainer)** yang disediakan oleh `ProviderScope`.

Semua provider yang kamu deklarasikan akan otomatis **terdaftar di container ini**, dan dapat diakses dari mana pun di widget tree (selama berada di dalam `ProviderScope`).

Bahkan, kamu bisa membuat `ProviderContainer` manual untuk *testing* atau *background logic*:

```dart
final container = ProviderContainer();
final count = container.read(counterProvider);
```

---

## ✅ 4. Kesimpulan

| Aspek                                          | Provider (lama) | Riverpod                     |
| ---------------------------------------------- | --------------- | ---------------------------- |
| Harus wrap widget?                             | ✅ Ya            | ❌ Tidak                      |
| Butuh BuildContext untuk read/watch?           | ✅ Ya            | ❌ Tidak                      |
| Bisa diakses dari mana saja (mis. background)? | ❌ Sulit         | ✅ Bisa                       |
| Auto dispose dan dependency injection?         | ⚙️ Terbatas     | ✅ Built-in                   |
| Code generation support                        | ❌               | ✅ Ada (`riverpod_generator`) |

---

Kalau kamu mau, saya bisa kasih **diagram alur bagaimana Riverpod mengelola provider tanpa wrapping context**, biar lebih mudah divisualisasikan.
Apakah kamu mau saya buatkan diagram tersebut?

Baik — mari kita bahas secara **lengkap dan sistematis** tentang **penggunaan Riverpod dalam Flutter** beserta **konvensi struktur proyek** yang umum digunakan oleh developer profesional.

---

## 🧩 1. Apa itu Riverpod?

**Riverpod** adalah *state management library* untuk Flutter yang dikembangkan oleh **Remi Rousselet** (pembuat Provider).
Riverpod memperbaiki berbagai keterbatasan Provider, seperti:

- Tidak bergantung pada `BuildContext`
- Aman dari *provider scoping* yang salah
- Mendukung *code generation* (melalui `riverpod_generator`)
- Lebih mudah untuk *testing* dan *refactoring*

---

## ⚙️ 2. Instalasi Dasar

Tambahkan dependensi di `pubspec.yaml`:

```yaml
dependencies:
  flutter:
    sdk: flutter
  flutter_riverpod: ^3.0.0
```

Jika ingin menggunakan *code generation* (recommended):

```yaml
dev_dependencies:
  riverpod_generator: ^3.0.0
  build_runner: ^2.4.0
```

---

## 🧠 3. Konsep Dasar Riverpod

Riverpod menggunakan konsep **provider** untuk mendeklarasikan *state* atau *logic* yang bisa di-*watch*, *read*, atau *listen*.

### Jenis Provider Umum

| Jenis Provider          | Kegunaan                                                      |
| ----------------------- | ------------------------------------------------------------- |
| `Provider`              | Menyediakan data statis atau objek non-state                  |
| `StateProvider`         | Menyimpan dan mengubah nilai sederhana (counter, toggle, dll) |
| `StateNotifierProvider` | Mengelola state kompleks dengan class `StateNotifier`         |
| `FutureProvider`        | Untuk operasi async (seperti HTTP request)                    |
| `StreamProvider`        | Untuk data berbasis stream                                    |

---

## 🧩 4. Contoh Dasar

### Contoh `StateProvider`

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/material.dart';

final counterProvider = StateProvider<int>((ref) => 0);

void main() {
  runApp(ProviderScope(child: MyApp()));
}

class MyApp extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final count = ref.watch(counterProvider);
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(title: Text('Riverpod Counter')),
        body: Center(
          child: Text('Count: $count', style: TextStyle(fontSize: 32)),
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: () => ref.read(counterProvider.notifier).state++,
          child: Icon(Icons.add),
        ),
      ),
    );
  }
}
```

---

## 🚀 5. Menggunakan `StateNotifierProvider` untuk State Kompleks

### Contoh

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

class CounterNotifier extends StateNotifier<int> {
  CounterNotifier() : super(0);

  void increment() => state++;
  void decrement() => state--;
}

final counterNotifierProvider = StateNotifierProvider<CounterNotifier, int>(
  (ref) => CounterNotifier(),
);
```

Dan di widget:

```dart
class CounterPage extends ConsumerWidget {
  const CounterPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final count = ref.watch(counterNotifierProvider);

    return Scaffold(
      body: Center(child: Text('$count', style: TextStyle(fontSize: 32))),
      floatingActionButton: Row(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          FloatingActionButton(
            onPressed: () => ref.read(counterNotifierProvider.notifier).increment(),
            child: Icon(Icons.add),
          ),
          SizedBox(width: 10),
          FloatingActionButton(
            onPressed: () => ref.read(counterNotifierProvider.notifier).decrement(),
            child: Icon(Icons.remove),
          ),
        ],
      ),
    );
  }
}
```

---

## 📁 6. Konvensi Struktur Proyek Riverpod (Clean Architecture Style)

Struktur yang direkomendasikan agar proyek tetap **scalable dan maintainable**:

```yml
lib/
│
├── main.dart
├── app/
│   ├── app.dart                 # Root widget (MaterialApp)
│   ├── router.dart              # Route management
│   └── theme.dart               # Theme setup
│
├── core/
│   ├── exceptions/
│   ├── failure.dart
│   ├── utils/
│   ├── constants/
│   └── services/                # Shared services (e.g., Dio, Firebase)
│
├── features/
│   ├── counter/
│   │   ├── data/                # Repository, data sources
│   │   ├── domain/              # Entities & business logic
│   │   ├── presentation/        # UI layer
│   │   │   ├── pages/
│   │   │   ├── widgets/
│   │   │   └── controllers/     # StateNotifiers or Providers
│   │   └── providers.dart       # Provider declarations
│   │
│   └── auth/
│       ├── data/
│       ├── domain/
│       ├── presentation/
│       └── providers.dart
│
└── shared/
    ├── widgets/                 # Common reusable widgets
    └── providers/               # Global providers
```

### 📌 Catatan

- Setiap **feature** memiliki folder sendiri (misalnya `counter`, `auth`, `todo`).
- Semua provider dideklarasikan di `providers.dart` pada masing-masing fitur.
- Jika menggunakan code generation (`riverpod_generator`), file provider akan otomatis dibuat dengan suffix `.g.dart`.

---

## 🧪 7. Menggunakan Riverpod Generator (opsional tapi disarankan)

Deklarasi provider menggunakan anotasi:

```dart
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'counter_provider.g.dart';

@riverpod
class Counter extends _$Counter {
  @override
  int build() => 0;

  void increment() => state++;
  void decrement() => state--;
}
```

Jalankan:

```bash
flutter pub run build_runner watch --delete-conflicting-outputs
```

Riverpod akan menghasilkan:

```dart
final counterProvider = AutoDisposeNotifierProvider<Counter, int>(Counter.new);
```

Kemudian gunakan seperti biasa:

```dart
ref.watch(counterProvider);
ref.read(counterProvider.notifier).increment();
```

---

## ✅ 8. Keunggulan Riverpod

- Tidak tergantung pada `BuildContext`
- Mudah untuk testing
- Kompatibel dengan arsitektur berskala besar (Clean Architecture, MVVM, dsb)
- Bisa dipakai di luar widget tree (misalnya di background isolate)
- Mendukung *auto dispose* untuk efisiensi memori

---

Kalau kamu mau, saya bisa bantu buatkan **template folder proyek Flutter dengan Riverpod (Clean Architecture)** lengkap dengan contoh provider dan halaman counter.
Apakah kamu mau saya buatkan strukturnya dalam bentuk kode atau file ZIP siap pakai?
