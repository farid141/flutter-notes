# Wide State Management

Untuk mengelola state yang lebih dalam kita dapat melakukan dengan beberapa cara.

## Package Pihak Petiga

`Riverpod` versi modern dari `Provider` dengan penulis yang sama. Ada 2 konsep utama dalam penggunaan `wide-state-management` ini.

```bash
flutter pub add flutter_riverpod
flutter pub add riverpod_annotation
flutter pub add riverpod_generator
flutter pub add build_runner
```

Disini akan dibahas secara spesifik wide state management menggunakan riverpod.

### 1. Wrap Komponen

Wrap kompnonen dengan `ProviderScope`

```dart
void main(){
    runApp(const ProviderScope(child: App()))
}
```

### 2. Provider

Terdapat beberapa jenis provider yang bisa digunakan:

- Provider â†’ Read-only values
- StateProvider â†’ Simple state management
- FutureProvider â†’ Async data (e.g., API calls)
- StreamProvider â†’ Real-time updates (e.g., Firebase)
- StateNotifierProvider â†’ Advanced state management

```dart
// read-only
final mealsProvider = Provider((ref){
    return dummyMeals
})

// read and write
final counterProvider = StateProvider<int>((ref) => 0);
final count = ref.watch(counterProvider); // read in component
onPressed: () => ref.read(counterProvider.notifier).state++,  // write in component
```

### StateProvider VS StateNotifier

Kita ambil kasus **Todo App** (sederhana tapi cukup kompleks untuk membedakan).

#### StateProvider

Kalau pakai `StateProvider`, kita langsung simpan list todo di dalamnya.

Semua logika (nambah, hapus, toggle) dilakukan di luar.

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Model sederhana
class Todo {
  final String id;
  final String title;
  final bool completed;

  Todo({
    required this.id,
    required this.title,
    this.completed = false,
  });

  Todo copyWith({String? title, bool? completed}) {
    return Todo(
      id: id,
      title: title ?? this.title,
      completed: completed ?? this.completed,
    );
  }
}

// StateProvider: langsung simpan list Todo
final todosProvider = StateProvider<List<Todo>>((ref) => []);

// Contoh penggunaan di widget
// Tambah todo
void addTodo(WidgetRef ref, String title) {
  final todos = ref.read(todosProvider.notifier);
  todos.state = [
    ...todos.state,
    Todo(id: DateTime.now().toString(), title: title),
  ];
}

// Toggle
void toggleTodo(WidgetRef ref, String id) {
  final todos = ref.read(todosProvider.notifier);
  todos.state = todos.state.map((todo) {
    if (todo.id == id) {
      return todo.copyWith(completed: !todo.completed);
    }
    return todo;
  }).toList();
}
```

ğŸ‘‰ Kekurangan: logika bercampur di luar provider, kode bisa cepat berantakan kalau fitur makin banyak.

#### StateNotifier

Di sini kita bikin class khusus (`TodoNotifier`) untuk mengelola semua logika.
State lebih terorganisir, gampang dikembangkan.

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Model sama dengan sebelumnya
class Todo {
  final String id;
  final String title;
  final bool completed;

  Todo({
    required this.id,
    required this.title,
    this.completed = false,
  });

  Todo copyWith({String? title, bool? completed}) {
    return Todo(
      id: id,
      title: title ?? this.title,
      completed: completed ?? this.completed,
    );
  }
}

// StateNotifier untuk mengelola list Todo
class TodoNotifier extends StateNotifier<List<Todo>> {
  TodoNotifier() : super([]);

  void add(String title) {
    state = [
      ...state,
      Todo(id: DateTime.now().toString(), title: title),
    ];
  }

  void toggle(String id) {
    state = state.map((todo) {
      if (todo.id == id) {
        return todo.copyWith(completed: !todo.completed);
      }
      return todo;
    }).toList();
  }

  void remove(String id) {
    state = state.where((todo) => todo.id != id).toList();
  }
}

// Provider
final todosProvider =
    StateNotifierProvider<TodoNotifier, List<Todo>>((ref) => TodoNotifier());
```

ğŸ‘‰ Keuntungan: semua logika terkapsulasi di dalam `TodoNotifier`, gampang dipakai di UI:

```dart
ref.read(todosProvider.notifier).add("Belajar Riverpod"); // Tambah
ref.read(todosProvider.notifier).toggle(todoId); // Toggle
ref.read(todosProvider.notifier).remove(todoId); // Remove
```

### Consumer

Ganti class widget untuk extend dari `ConsumerWidget` jika stateless dan `ConsumerStatefulWidget` jika statefull.

Ganti class state untuk extend dari `ConsumerState` jika statefull.

Didalamnya kita bisa maengakses variabel `ref.watch(stateName)` di `build` agar dire-render ketika perubahan terjadi.

## ğŸ”‘ Inti Perbedaan di Contoh Ini

- **`StateProvider`** â†’ data + logika bercampur di widget atau helper function.
- **`StateNotifier`** â†’ logika dikelompokkan di satu tempat (class), lebih mudah dipelihara & scalable.

Keren ğŸ‘ â€” berikut penjelasan **visual + konsep alur kerja Riverpod** dalam bentuk diagram dan narasi supaya kamu paham **kenapa nggak perlu wrapping provider di parent widget** seperti di React atau `provider` Flutter lama.

---

## ğŸ§­ **Konsep Umum: â€œGlobal Provider Containerâ€**

```yml
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚        ProviderScope       â”‚   â† satu kali di root app
        â”‚ (menyediakan container)    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚     ProviderContainer      â”‚
        â”‚ (tempat semua provider     â”‚
        â”‚  didaftarkan & di-manage)  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                                 â”‚
     â–¼                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ counterProvider â”‚            â”‚ authProvider â”‚
â”‚ (StateProvider) â”‚            â”‚ (FutureProv.)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                                 â”‚
     â–¼                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Widget A     â”‚               â”‚ Widget B     â”‚
â”‚ ref.watch(...)â”‚              â”‚ ref.read(...)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ§© **Alur Kerja**

1. **`ProviderScope`** di `main.dart` hanya **sekali**:

   ```dart
   void main() {
     runApp(ProviderScope(child: MyApp()));
   }
   ```

   Ini membuat sebuah **`ProviderContainer`**, yaitu tempat semua provider hidup.

2. Kamu mendefinisikan provider di mana pun:

   ```dart
   final counterProvider = StateProvider<int>((ref) => 0);
   ```

3. Saat kamu panggil di widget:

   ```dart
   final count = ref.watch(counterProvider);
   ```

   Maka `ref` akan:

   - Minta nilai ke `ProviderContainer`
   - Kalau belum ada instance â†’ dibuat otomatis
   - Kalau sudah ada â†’ ambil state terkini

4. Semua dependensi antar-provider dikelola otomatis oleh container (termasuk disposal dan reactivity).

---

## ğŸ§  **Analogi Singkat**

Bayangkan `ProviderScope` itu seperti **power station** âš¡
Semua `provider` kamu (counter, auth, theme, dsb) seperti **jalur listrik**.

Setiap widget yang butuh state cukup **colok ke stop kontak** (`ref.watch(provider)`) tanpa perlu bikin power station sendiri.

---

## ğŸ§± **Bonus: Gimana Kalau Butuh Scope Khusus**

Kamu **bisa** punya scope provider lokal (misal di halaman tertentu):

```dart
ProviderScope(
  overrides: [
    counterProvider.overrideWith((ref) => StateController(100)),
  ],
  child: CounterPage(),
);
```

â¡ï¸ Ini membuat container baru hanya untuk `CounterPage`, tapi tetap tidak perlu â€œmembungkus providerâ€ satu per satu.

---

## âœ… **Kesimpulan**

| Konsep                   | Provider (lama) | Riverpod          |
| ------------------------ | --------------- | ----------------- |
| Harus wrap tiap provider | âœ… Ya            | âŒ Tidak           |
| Context-bound            | âœ… Ya            | âŒ Tidak           |
| Global management        | âš™ï¸ Terbatas     | âœ… `ProviderScope` |
| Multi-scope support      | âŒ Rumit         | âœ… Built-in        |
| Dependency injection     | âš™ï¸ Manual       | âœ… Otomatis        |

---

Kalau kamu mau, saya bisa bantu lanjut bikin **diagram versi visual (gambar)** dari arsitektur ini â€” mirip mindmap atau flowchart gaya profesional.
Apakah kamu mau saya buatkan diagram visualnya?

âœ… Tepat sekali!
Ini salah satu **perbedaan utama** dan **kekuatan Riverpod** dibandingkan state management lain seperti **Provider** di Flutter atau **Context API** di React.

Mari saya jelaskan dengan detail biar kamu benar-benar paham konsepnya ğŸ‘‡

---

## ğŸ§© 1. Perbedaan Filosofi Dasar

### ğŸ§  Di React (atau Flutter Provider)

Kamu **harus membungkus** komponen/Widget parent dengan provider agar context bisa di-*consume* di bawahnya.

Contoh React (atau Flutter Provider):

```dart
// Provider (lama)
return ChangeNotifierProvider(
  create: (_) => CounterNotifier(),
  child: MyApp(),
);
```

â¡ï¸ Artinya, setiap widget yang butuh state harus *dalam tree* provider itu.

Kalau salah scope (misal provider tidak di atas widget yang butuh), akan muncul error seperti:

> â€œProvider not found for contextâ€

---

### âš™ï¸ Di Riverpod

Kamu **tidak perlu membungkus** widget dengan provider manual.

Cukup **daftarkan provider-nya di mana saja** (biasanya di file `.dart` terpisah), lalu **gunakan langsung dengan import dan `ref.watch()`**.

Satu-satunya hal yang perlu kamu lakukan di level global hanya:

```dart
runApp(ProviderScope(child: MyApp()));
```

Itu *sekali saja di root app* â€” Riverpod yang akan mengurus semua provider di dalamnya.

---

## ğŸ“¦ 2. Contoh Perbandingan

### Tanpa Riverpod (Provider)

```dart
ChangeNotifierProvider(
  create: (_) => CounterNotifier(),
  child: MyApp(),
);
```

### Dengan Riverpod

```dart
void main() {
  runApp(const ProviderScope(child: MyApp())); // hanya ini
}
```

Kemudian di file manapun:

```dart
final counterProvider = StateProvider<int>((ref) => 0);
```

Lalu di widget:

```dart
class CounterPage extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final count = ref.watch(counterProvider);
    return Text('$count');
  }
}
```

â¡ï¸ Kamu hanya perlu **import file provider-nya**, tidak perlu bungkus widget dengan provider lagi.

---

## âš¡ 3. Kenapa Bisa Begitu?

Karena Riverpod menggunakan **container global (ProviderContainer)** yang disediakan oleh `ProviderScope`.

Semua provider yang kamu deklarasikan akan otomatis **terdaftar di container ini**, dan dapat diakses dari mana pun di widget tree (selama berada di dalam `ProviderScope`).

Bahkan, kamu bisa membuat `ProviderContainer` manual untuk *testing* atau *background logic*:

```dart
final container = ProviderContainer();
final count = container.read(counterProvider);
```

---

## âœ… 4. Kesimpulan

| Aspek                                          | Provider (lama) | Riverpod                     |
| ---------------------------------------------- | --------------- | ---------------------------- |
| Harus wrap widget?                             | âœ… Ya            | âŒ Tidak                      |
| Butuh BuildContext untuk read/watch?           | âœ… Ya            | âŒ Tidak                      |
| Bisa diakses dari mana saja (mis. background)? | âŒ Sulit         | âœ… Bisa                       |
| Auto dispose dan dependency injection?         | âš™ï¸ Terbatas     | âœ… Built-in                   |
| Code generation support                        | âŒ               | âœ… Ada (`riverpod_generator`) |

---

Kalau kamu mau, saya bisa kasih **diagram alur bagaimana Riverpod mengelola provider tanpa wrapping context**, biar lebih mudah divisualisasikan.
Apakah kamu mau saya buatkan diagram tersebut?

Baik â€” mari kita bahas secara **lengkap dan sistematis** tentang **penggunaan Riverpod dalam Flutter** beserta **konvensi struktur proyek** yang umum digunakan oleh developer profesional.

---

## ğŸ§© 1. Apa itu Riverpod?

**Riverpod** adalah *state management library* untuk Flutter yang dikembangkan oleh **Remi Rousselet** (pembuat Provider).
Riverpod memperbaiki berbagai keterbatasan Provider, seperti:

- Tidak bergantung pada `BuildContext`
- Aman dari *provider scoping* yang salah
- Mendukung *code generation* (melalui `riverpod_generator`)
- Lebih mudah untuk *testing* dan *refactoring*

---

## âš™ï¸ 2. Instalasi Dasar

Tambahkan dependensi di `pubspec.yaml`:

```yaml
dependencies:
  flutter:
    sdk: flutter
  flutter_riverpod: ^3.0.0
```

Jika ingin menggunakan *code generation* (recommended):

```yaml
dev_dependencies:
  riverpod_generator: ^3.0.0
  build_runner: ^2.4.0
```

---

## ğŸ§  3. Konsep Dasar Riverpod

Riverpod menggunakan konsep **provider** untuk mendeklarasikan *state* atau *logic* yang bisa di-*watch*, *read*, atau *listen*.

### Jenis Provider Umum

| Jenis Provider          | Kegunaan                                                      |
| ----------------------- | ------------------------------------------------------------- |
| `Provider`              | Menyediakan data statis atau objek non-state                  |
| `StateProvider`         | Menyimpan dan mengubah nilai sederhana (counter, toggle, dll) |
| `StateNotifierProvider` | Mengelola state kompleks dengan class `StateNotifier`         |
| `FutureProvider`        | Untuk operasi async (seperti HTTP request)                    |
| `StreamProvider`        | Untuk data berbasis stream                                    |

---

## ğŸ§© 4. Contoh Dasar

### Contoh `StateProvider`

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/material.dart';

final counterProvider = StateProvider<int>((ref) => 0);

void main() {
  runApp(ProviderScope(child: MyApp()));
}

class MyApp extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final count = ref.watch(counterProvider);
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(title: Text('Riverpod Counter')),
        body: Center(
          child: Text('Count: $count', style: TextStyle(fontSize: 32)),
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: () => ref.read(counterProvider.notifier).state++,
          child: Icon(Icons.add),
        ),
      ),
    );
  }
}
```

---

## ğŸš€ 5. Menggunakan `StateNotifierProvider` untuk State Kompleks

### Contoh

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

class CounterNotifier extends StateNotifier<int> {
  CounterNotifier() : super(0);

  void increment() => state++;
  void decrement() => state--;
}

final counterNotifierProvider = StateNotifierProvider<CounterNotifier, int>(
  (ref) => CounterNotifier(),
);
```

Dan di widget:

```dart
class CounterPage extends ConsumerWidget {
  const CounterPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final count = ref.watch(counterNotifierProvider);

    return Scaffold(
      body: Center(child: Text('$count', style: TextStyle(fontSize: 32))),
      floatingActionButton: Row(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          FloatingActionButton(
            onPressed: () => ref.read(counterNotifierProvider.notifier).increment(),
            child: Icon(Icons.add),
          ),
          SizedBox(width: 10),
          FloatingActionButton(
            onPressed: () => ref.read(counterNotifierProvider.notifier).decrement(),
            child: Icon(Icons.remove),
          ),
        ],
      ),
    );
  }
}
```

---

## ğŸ“ 6. Konvensi Struktur Proyek Riverpod (Clean Architecture Style)

Struktur yang direkomendasikan agar proyek tetap **scalable dan maintainable**:

```yml
lib/
â”‚
â”œâ”€â”€ main.dart
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ app.dart                 # Root widget (MaterialApp)
â”‚   â”œâ”€â”€ router.dart              # Route management
â”‚   â””â”€â”€ theme.dart               # Theme setup
â”‚
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ exceptions/
â”‚   â”œâ”€â”€ failure.dart
â”‚   â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ constants/
â”‚   â””â”€â”€ services/                # Shared services (e.g., Dio, Firebase)
â”‚
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ counter/
â”‚   â”‚   â”œâ”€â”€ data/                # Repository, data sources
â”‚   â”‚   â”œâ”€â”€ domain/              # Entities & business logic
â”‚   â”‚   â”œâ”€â”€ presentation/        # UI layer
â”‚   â”‚   â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”‚   â”œâ”€â”€ widgets/
â”‚   â”‚   â”‚   â””â”€â”€ controllers/     # StateNotifiers or Providers
â”‚   â”‚   â””â”€â”€ providers.dart       # Provider declarations
â”‚   â”‚
â”‚   â””â”€â”€ auth/
â”‚       â”œâ”€â”€ data/
â”‚       â”œâ”€â”€ domain/
â”‚       â”œâ”€â”€ presentation/
â”‚       â””â”€â”€ providers.dart
â”‚
â””â”€â”€ shared/
    â”œâ”€â”€ widgets/                 # Common reusable widgets
    â””â”€â”€ providers/               # Global providers
```

### ğŸ“Œ Catatan

- Setiap **feature** memiliki folder sendiri (misalnya `counter`, `auth`, `todo`).
- Semua provider dideklarasikan di `providers.dart` pada masing-masing fitur.
- Jika menggunakan code generation (`riverpod_generator`), file provider akan otomatis dibuat dengan suffix `.g.dart`.

---

## ğŸ§ª 7. Menggunakan Riverpod Generator (opsional tapi disarankan)

Deklarasi provider menggunakan anotasi:

```dart
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'counter_provider.g.dart';

@riverpod
class Counter extends _$Counter {
  @override
  int build() => 0;

  void increment() => state++;
  void decrement() => state--;
}
```

Jalankan:

```bash
flutter pub run build_runner watch --delete-conflicting-outputs
```

Riverpod akan menghasilkan:

```dart
final counterProvider = AutoDisposeNotifierProvider<Counter, int>(Counter.new);
```

Kemudian gunakan seperti biasa:

```dart
ref.watch(counterProvider);
ref.read(counterProvider.notifier).increment();
```

---

## âœ… 8. Keunggulan Riverpod

- Tidak tergantung pada `BuildContext`
- Mudah untuk testing
- Kompatibel dengan arsitektur berskala besar (Clean Architecture, MVVM, dsb)
- Bisa dipakai di luar widget tree (misalnya di background isolate)
- Mendukung *auto dispose* untuk efisiensi memori

---

Kalau kamu mau, saya bisa bantu buatkan **template folder proyek Flutter dengan Riverpod (Clean Architecture)** lengkap dengan contoh provider dan halaman counter.
Apakah kamu mau saya buatkan strukturnya dalam bentuk kode atau file ZIP siap pakai?
