# SQLite

Merupakan database local bisa diakses secara offline. Biasa digunakan untuk aplikasi mobile untuk kemampuan `offline first`

SQLite adalah **database lokal (embedded)** yang ringan, cepat, dan tidak butuh server tambahan. Di Flutter, SQLite biasanya dipakai untuk aplikasi yang butuh **penyimpanan data permanen di perangkat**, contohnya:

* Aplikasi catatan (note-taking)
* Aplikasi todo-list / task manager
* Aplikasi keuangan offline
* Aplikasi katalog (misalnya daftar produk, buku, atau musik)

---

## ğŸ”¹ Cara Mengaplikasikan SQLite di Flutter

Umumnya menggunakan package [`sqflite`](https://pub.dev/packages/sqflite) (paling populer) + `path` untuk menentukan lokasi database.

### 1. Tambahkan dependency

Di `pubspec.yaml`:

```yaml
dependencies:
  sqflite: ^2.3.0
  path: ^1.8.3
```

### 2. Buat helper untuk database

Biasanya kita buat class khusus, misalnya `db_helper.dart`.

```dart
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';

class DatabaseHelper {
  static final DatabaseHelper instance = DatabaseHelper._init();
  static Database? _database;

  DatabaseHelper._init();

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB('app.db');
    return _database!;
  }

  Future<Database> _initDB(String filePath) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, filePath);

    return await openDatabase(
      path,
      version: 1,
      onCreate: _createDB,
    );
  }

  Future _createDB(Database db, int version) async {
    await db.execute('''
      CREATE TABLE notes (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        content TEXT NOT NULL
      )
    ''');
  }

  Future<int> insert(String table, Map<String, Object?> data) async {
    final db = await instance.database;
    return await db.insert(table, data);
  }

  Future<List<Map<String, Object?>>> queryAll(String table) async {
    final db = await instance.database;
    return await db.query(table);
  }

  Future<int> update(String table, Map<String, Object?> data, int id) async {
    final db = await instance.database;
    return await db.update(table, data, where: 'id = ?', whereArgs: [id]);
  }

  Future<int> delete(String table, int id) async {
    final db = await instance.database;
    return await db.delete(table, where: 'id = ?', whereArgs: [id]);
  }
}
```

---

### 3. Buat model data (opsional, tapi best practice)

```dart
class Note {
  final int? id;
  final String title;
  final String content;

  Note({this.id, required this.title, required this.content});

  Map<String, Object?> toMap() {
    return {
      'id': id,
      'title': title,
      'content': content,
    };
  }

  factory Note.fromMap(Map<String, Object?> map) {
    return Note(
      id: map['id'] as int?,
      title: map['title'] as String,
      content: map['content'] as String,
    );
  }
}
```

### 4. Gunakan di UI Flutter

Misalnya menambahkan catatan:

```dart
final db = DatabaseHelper.instance;

// Insert
await db.insert('notes', {
  'title': 'Belajar SQLite',
  'content': 'SQLite di Flutter menggunakan sqflite package'
});

// Query
final notes = await db.queryAll('notes');
notes.forEach((row) {
  print(row);
});

// Update
await db.update('notes', {'title': 'Update Judul', 'content': 'Isi baru'}, 1);

// Delete
await db.delete('notes', 1);
```

---

## ğŸ”¹ Kelebihan SQLite di Flutter

âœ… Data **persisten** meskipun aplikasi ditutup
âœ… Tidak butuh server / internet
âœ… Cepat dan efisien untuk data kecil hingga menengah
âœ… Cocok untuk aplikasi offline-first

## ğŸ”¹ Kekurangan

âŒ Tidak cocok untuk data **besar & kompleks** (lebih baik pakai server/database eksternal)
âŒ Tidak ada mekanisme **sinkronisasi otomatis** antar device
âŒ Perlu penanganan manual untuk migrasi versi database

## Integrasi Server

Kalau kita sudah punya **SQLite (lokal)** di aplikasi Flutter, lalu ingin **terintegrasi dengan database online (misalnya MySQL, PostgreSQL, MongoDB, Firebase, Supabase, atau backend API custom)**, biasanya konsep yang dipakai adalah:

## ğŸ”¹ Pola Umum Integrasi SQLite + Database Online

SQLite hanya **lokal di device**, jadi dia tidak bisa langsung â€œconnectâ€ ke server database online. Biasanya pola yang dipakai:

1. **Server menyediakan API (REST/GraphQL/gRPC)**

   * Database online (misalnya MySQL/Postgres) diakses lewat backend (Node.js, FastAPI, Laravel, Spring Boot, dll).
   * Flutter **memanggil API** â†’ dapat response JSON â†’ simpan ke SQLite.

2. **SQLite jadi local cache / offline storage**

   * Aplikasi tetap bisa dipakai walau offline.
   * Saat ada internet, aplikasi **sinkronisasi data** dengan server (upload perubahan lokal, download update terbaru).

## ğŸ”¹ Alur Kerja Sinkronisasi (Contoh Todo App)

1. **Startup App**

   * Cek SQLite â†’ tampilkan data dari database lokal.
   * (Opsional) Panggil API untuk sync â†’ update SQLite.

2. **User Tambah / Edit / Hapus data**

   * Simpan dulu ke SQLite.
   * Tandai status data: `pending_sync` atau `is_synced = false`.

3. **Saat ada internet**

   * Kirim data pending ke server via API.
   * Ambil data terbaru dari server â†’ merge/update ke SQLite.

4. **Konflik Data**

   * Biasanya pakai timestamp (`updated_at`) atau versi data untuk menentukan siapa yang lebih baru.

## ğŸ”¹ Contoh Penerapan di Flutter

Misalnya kita punya API untuk notes:

* `GET /notes` â†’ ambil semua catatan
* `POST /notes` â†’ tambah catatan
* `PUT /notes/:id` â†’ update catatan
* `DELETE /notes/:id` â†’ hapus catatan

Di Flutter:

```dart
Future<void> syncNotes() async {
  final db = DatabaseHelper.instance;

  // 1. Ambil data lokal yang belum di-sync
  final localNotes = await db.queryAll('notes');
  for (var note in localNotes) {
    if (note['is_synced'] == 0) {
      // Kirim ke server
      await http.post(
        Uri.parse('https://example.com/api/notes'),
        body: {
          'title': note['title'],
          'content': note['content'],
        },
      );

      // Update status synced
      await db.update('notes', {'is_synced': 1}, note['id']);
    }
  }

  // 2. Ambil data terbaru dari server
  final response = await http.get(Uri.parse('https://example.com/api/notes'));
  if (response.statusCode == 200) {
    final List<dynamic> serverNotes = jsonDecode(response.body);
    for (var note in serverNotes) {
      await db.insert('notes', {
        'id': note['id'],
        'title': note['title'],
        'content': note['content'],
        'is_synced': 1
      });
    }
  }
}
```

---

## ğŸ”¹ Tools & Paket yang Membantu

* [`sqflite`](https://pub.dev/packages/sqflite) â†’ SQLite lokal
* [`drift`](https://pub.dev/packages/drift) â†’ ORM untuk SQLite (lebih rapi daripada raw SQL)
* [`dio`](https://pub.dev/packages/dio) atau `http` â†’ request ke API online
* [`connectivity_plus`](https://pub.dev/packages/connectivity_plus) â†’ cek status internet
* [`hive`](https://pub.dev/packages/hive) â†’ alternatif SQLite untuk local storage yang lebih ringan

---

## ğŸ”¹ Kapan SQLite + Online Database Berguna?

âœ… Aplikasi **offline-first** (jalan walau tanpa internet)
âœ… Data **tidak terlalu besar** tapi butuh persistensi
âœ… Ada kebutuhan **sinkronisasi** antar device/user

Contoh nyata:

* WhatsApp â†’ chat tersimpan di device (SQLite) + backup/sync ke server
* Aplikasi keuangan â†’ input transaksi bisa offline, nanti sync ke cloud
* Aplikasi field worker â†’ catat data di lapangan tanpa internet, sync saat online

---

Jadi intinya: **SQLite dipakai untuk cache/offline**, sedangkan **server database tetap via API**.
Kalau kamu mau, saya bisa bikinkan **arsitektur sinkronisasi SQLite + API** dalam bentuk diagram supaya lebih jelas. Mau saya buatkan?
